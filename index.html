export default {
  async fetch(request, env, ctx) {
    const upstream = 'https://www.reloadedskidrow.com'; // <-- target site
    const reqURL = new URL(request.url);
    const targetURL = new URL(reqURL.pathname + reqURL.search, upstream);

    const method = request.method;
    const isBodyMethod = method !== 'GET' && method !== 'HEAD';
    const body = isBodyMethod ? await request.arrayBuffer() : undefined;

    const res = await fetch(targetURL.toString(), {
      method,
      headers: buildUpstreamHeaders(request.headers, new URL(upstream).host),
      body,
      redirect: 'follow'
    });

    // Redirects: zorg dat absolute Location naar relative wordt geherschreven
    const location = res.headers.get('location');
    const headers = new Headers(res.headers);
    stripFrameBlockingHeaders(headers);
    if (location) {
      headers.set('location', toProxy(location));
    }

    const ctype = headers.get('content-type') || '';
    if (ctype.includes('text/html')) {
      const rewriter = new HTMLRewriter()
        .on('head', new InjectAntiBust())
        .on('a[href]', new RewriteAttr('href'))
        .on('link[href]', new RewriteAttr('href'))
        .on('script[src]', new RewriteAttr('src'))
        .on('img[src]', new RewriteAttr('src'))
        .on('source[srcset]', new RewriteSrcset('srcset'))
        .on('iframe[src]', new RewriteAttr('src'))
        .on('form[action]', new RewriteAttr('action'));

      return new Response(rewriter.transform(res).body, {
        status: res.status,
        headers
      });
    }

    // Non-HTML: pass-through (met opgeschoonde headers)
    return new Response(res.body, { status: res.status, headers });
  }
};

// ===== Helpers =====

function buildUpstreamHeaders(reqHeaders, upstreamHost) {
  const h = new Headers(reqHeaders);
  // Host & Origin naar upstream
  h.set('Host', upstreamHost);
  h.set('Origin', `https://${upstreamHost}`);
  // Hop-by-hop headers verwijderen
  [
    'cf-connecting-ip',
    'x-forwarded-for',
    'x-forwarded-host',
    'x-forwarded-proto',
    'content-length'
  ].forEach(k => h.delete(k));
  return h;
}

function stripFrameBlockingHeaders(headers) {
  // X-Frame-Options weg
  headers.delete('x-frame-options');

  // CSP & CSP-Report-Only: frame-ancestors weghalen
  ['content-security-policy', 'content-security-policy-report-only'].forEach(h => {
    const csp = headers.get(h);
    if (csp) {
      const cleaned = csp
        .split(';')
        .map(s => s.trim())
        .filter(s => s && !/^frame-ancestors/i.test(s))
        .join('; ');
      headers.set(h, cleaned);
    }
  });

  // CORS iets soepeler voor assets
  if (!headers.has('access-control-allow-origin')) {
    headers.set('access-control-allow-origin', '*');
  }
}

class InjectAntiBust {
  element(el) {
    // Injecteer een guard tegen veelvoorkomende frame-busters
    el.append(`
<script>
(function(){
  // Markering: bewust embedded
  window.__ALLOW_IFRAME__ = true;

  if (self !== top) {
    try {
      // Blokkeer pogingen om top te navigeren
      const noop = function(){};
      try { Object.defineProperty(window.location, 'assign', { configurable:true, writable:true, value: noop }); } catch(e){}
      try { Object.defineProperty(window.location, 'replace', { configurable:true, writable:true, value: noop }); } catch(e){}
      try { history.pushState = noop; history.replaceState = noop; } catch(e){}

      // Kill interval/timeout busters die top.location zetten
      const _si = setInterval, _so = setTimeout;
      setInterval = function(fn, t){
        const s = (fn && fn.toString ? fn.toString() : '');
        if (s.includes('top.location') || s.includes('parent.location')) return 0;
        return _si(fn, t);
      };
      setTimeout = function(fn, t){
        const s = (fn && fn.toString ? fn.toString() : '');
        if (s.includes('top.location') || s.includes('parent.location')) return 0;
        return _so(fn, t);
      };

      // Neutraliseer window.onbeforeunload spam
      try { window.onbeforeunload = null; } catch(e){}
    } catch(e){}
  }
})();
</script>
`, { html: true });
  }
}

// Zet absolute upstream-URLs om naar relative paden, zodat verzoeken via de Worker-route blijven lopen
function toProxy(urlStr) {
  try {
    const test = new URL(urlStr, 'https://dummy.local'); // parse ook relative waarden
    // data:, mailto:, tel:, javascript: e.d. ongemoeid laten
    if (test.protocol === 'data:' || test.protocol === 'mailto:' || test.protocol === 'tel:' || test.protocol === 'javascript:') {
      return urlStr;
    }
  } catch { return urlStr; }

  // Strip protocol+host, behoud pad+query+hash â†’ relative naar dezelfde Worker origin/route
  return urlStr.replace(/^https?:\/\/[^/]+/i, '');
}

class RewriteAttr {
  constructor(attr) { this.attr = attr; }
  element(el) {
    const val = el.getAttribute(this.attr);
    if (!val) return;
    if (val.startsWith('#') || val.startsWith('mailto:') || val.startsWith('tel:') || val.startsWith('javascript:')) return;
    el.setAttribute(this.attr, toProxy(val));
  }
}

class RewriteSrcset {
  constructor(attr) { this.attr = attr; }
  element(el) {
    const val = el.getAttribute(this.attr);
    if (!val) return;
    const parts = val.split(',').map(s => s.trim()).map(item => {
      const m = item.match(/^(\S+)(\s+.+)?$/);
      if (!m) return item;
      const url = m[1];
      const desc = m[2] || '';
      return toProxy(url) + desc;
    });
    el.setAttribute(this.attr, parts.join(', '));
  }
}
